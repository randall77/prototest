// Code generated by protoc-gen-go.
// source: msg.proto
// DO NOT EDIT!

/*
Package protobench is a generated protocol buffer package.

It is generated from these files:
	msg.proto

It has these top-level messages:
	A
	B
	B2
	B3
*/
package protobench

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// This message is intentionally designed
// so that it can parse without allocation.
// Allocation is incredibly important, but it is
// also noisy.  Nice to have one benchmark that
// provides repeatable numbers.
type A struct {
	F1  int64   `protobuf:"varint,1,opt,name=f1" json:"f1,omitempty"`
	F2  int64   `protobuf:"varint,2,opt,name=f2" json:"f2,omitempty"`
	F3  int32   `protobuf:"varint,3,opt,name=f3" json:"f3,omitempty"`
	F4  bool    `protobuf:"varint,4,opt,name=f4" json:"f4,omitempty"`
	F5  float32 `protobuf:"fixed32,5,opt,name=f5" json:"f5,omitempty"`
	F6  float64 `protobuf:"fixed64,6,opt,name=f6" json:"f6,omitempty"`
	F7  uint64  `protobuf:"fixed64,7,opt,name=f7" json:"f7,omitempty"`
	F8  uint32  `protobuf:"fixed32,8,opt,name=f8" json:"f8,omitempty"`
	F9  int32   `protobuf:"zigzag32,9,opt,name=f9" json:"f9,omitempty"`
	F10 int64   `protobuf:"zigzag64,10,opt,name=f10" json:"f10,omitempty"`
}

func (m *A) Reset()                    { *m = A{} }
func (m *A) String() string            { return proto.CompactTextString(m) }
func (*A) ProtoMessage()               {}
func (*A) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *A) MergeFullCustom(b []byte) error {
loop:
	for {
		if len(b) == 0 {
			break
		}
		switch b[0] {
		case 8:
			b = b[1:]
			x, n := proto.DecodeVarint(b)
			if n == 0 {
				return proto.ErrInternalBadWireType
			}
			b = b[n:]
			v := int64(x)
			m.F1 = v
			continue loop
		case 16:
			b = b[1:]
			x, n := proto.DecodeVarint(b)
			if n == 0 {
				return proto.ErrInternalBadWireType
			}
			b = b[n:]
			v := int64(x)
			m.F2 = v
			continue loop
		case 24:
			b = b[1:]
			x, n := proto.DecodeVarint(b)
			if n == 0 {
				return proto.ErrInternalBadWireType
			}
			b = b[n:]
			v := int32(x)
			m.F3 = v
			continue loop
		case 32:
			b = b[1:]
			if len(b) == 0 {
				return proto.ErrInternalBadWireType
			}
			v := false
			if b[0] != 0 {
				v = true
			}
			b = b[1:]
			m.F4 = v
			continue loop
		case 45:
			b = b[1:]
			if len(b) < 4 {
				return proto.ErrInternalBadWireType
			}
			v := math.Float32frombits(uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24)
			b = b[4:]
			m.F5 = v
			continue loop
		case 49:
			b = b[1:]
			if len(b) < 8 {
				return proto.ErrInternalBadWireType
			}
			v := math.Float64frombits(uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56)
			b = b[8:]
			m.F6 = v
			continue loop
		case 57:
			b = b[1:]
			if len(b) < 8 {
				return proto.ErrInternalBadWireType
			}
			v := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56
			b = b[8:]
			m.F7 = v
			continue loop
		case 69:
			b = b[1:]
			if len(b) < 4 {
				return proto.ErrInternalBadWireType
			}
			v := uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24
			b = b[4:]
			m.F8 = v
			continue loop
		case 72:
			b = b[1:]
			x, n := proto.DecodeVarint(b)
			if n == 0 {
				return proto.ErrInternalBadWireType
			}
			b = b[n:]
			v := int32(x>>1) ^ int32(x)<<31>>31
			m.F9 = v
			continue loop
		case 80:
			b = b[1:]
			x, n := proto.DecodeVarint(b)
			if n == 0 {
				return proto.ErrInternalBadWireType
			}
			b = b[n:]
			v := int64(x>>1) ^ int64(x)<<63>>63
			m.F10 = v
			continue loop
		}
		b = proto.SkipUnrecognized2(b, nil)
	}
	return nil
}
func (m *A) MergeReflectTable(b []byte) error {
	return proto.UnmarshalReflect(m, b, &xxx_unmarshalInfoPtr_A)
}

var xxx_unmarshalInfoPtr_A *proto.UnmarshalInfo

// This message is designed to be more complicated.
type B struct {
	F1 []int64 `protobuf:"varint,1,rep,packed,name=f1" json:"f1,omitempty"`
	F2 *B2     `protobuf:"bytes,2,opt,name=f2" json:"f2,omitempty"`
	F3 []*B2   `protobuf:"bytes,3,rep,name=f3" json:"f3,omitempty"`
	F4 string  `protobuf:"bytes,4,opt,name=f4" json:"f4,omitempty"`
}

func (m *B) Reset()                    { *m = B{} }
func (m *B) String() string            { return proto.CompactTextString(m) }
func (*B) ProtoMessage()               {}
func (*B) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *B) GetF2() *B2 {
	if m != nil {
		return m.F2
	}
	return nil
}

func (m *B) GetF3() []*B2 {
	if m != nil {
		return m.F3
	}
	return nil
}

func (m *B) MergeFullCustom(b []byte) error {
	var rnse *proto.RequiredNotSetError
loop:
	for {
		if len(b) == 0 {
			break
		}
		switch b[0] {
		case 8:
			b = b[1:]
			x, n := proto.DecodeVarint(b)
			if n == 0 {
				return proto.ErrInternalBadWireType
			}
			b = b[n:]
			v := int64(x)
			m.F1 = append(m.F1, v)
			continue loop
		case 10:
			b = b[1:]
			x, n := proto.DecodeVarint(b)
			if n == 0 {
				return proto.ErrInternalBadWireType
			}
			b = b[n:]
			if x > uint64(len(b)) {
				return proto.ErrInternalBadWireType
			}
			p := b[:x]
			b = b[x:]
			for len(p) > 0 {
				x, n := proto.DecodeVarint(p)
				if n == 0 {
					return proto.ErrInternalBadWireType
				}
				p = p[n:]
				v := int64(x)
				m.F1 = append(m.F1, v)
			}
			continue loop
		case 18:
			b = b[1:]
			x, n := proto.DecodeVarint(b)
			if n == 0 {
				return proto.ErrInternalBadWireType
			}
			b = b[n:]
			if uint64(len(b)) < x {
				return proto.ErrInternalBadWireType
			}
			v := m.F2
			if v == nil {
				v = new(B2)
				m.F2 = v
			}
			if err := v.MergeFullCustom(b[:x]); err != nil {
				if r, ok := err.(*proto.RequiredNotSetError); ok {
					r.AddParent("f2")
					rnse = r
				} else {
					return err
				}
			}
			b = b[x:]
			continue loop
		case 26:
			b = b[1:]
			x, n := proto.DecodeVarint(b)
			if n == 0 {
				return proto.ErrInternalBadWireType
			}
			b = b[n:]
			if uint64(len(b)) < x {
				return proto.ErrInternalBadWireType
			}
			v := new(B2)
			if err := v.MergeFullCustom(b[:x]); err != nil {
				if r, ok := err.(*proto.RequiredNotSetError); ok {
					r.AddParent("f3")
					rnse = r
				} else {
					return err
				}
			}
			b = b[x:]
			m.F3 = append(m.F3, v)
			continue loop
		case 34:
			b = b[1:]
			x, n := proto.DecodeVarint(b)
			if n == 0 {
				return proto.ErrInternalBadWireType
			}
			b = b[n:]
			if uint64(len(b)) < x {
				return proto.ErrInternalBadWireType
			}
			v := string(b[:x])
			b = b[x:]
			m.F4 = v
			continue loop
		}
		b = proto.SkipUnrecognized2(b, nil)
	}
	if rnse != nil {
		return rnse
	}
	return nil
}
func (m *B) MergeReflectTable(b []byte) error {
	return proto.UnmarshalReflect(m, b, &xxx_unmarshalInfoPtr_B)
}

var xxx_unmarshalInfoPtr_B *proto.UnmarshalInfo

type B2 struct {
	F1 []float32 `protobuf:"fixed32,1,rep,packed,name=f1" json:"f1,omitempty"`
	F2 int64     `protobuf:"zigzag64,2,opt,name=f2" json:"f2,omitempty"`
	F3 []*B3     `protobuf:"bytes,3,rep,name=f3" json:"f3,omitempty"`
}

func (m *B2) Reset()                    { *m = B2{} }
func (m *B2) String() string            { return proto.CompactTextString(m) }
func (*B2) ProtoMessage()               {}
func (*B2) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *B2) GetF3() []*B3 {
	if m != nil {
		return m.F3
	}
	return nil
}

func (m *B2) MergeFullCustom(b []byte) error {
	var rnse *proto.RequiredNotSetError
loop:
	for {
		if len(b) == 0 {
			break
		}
		switch b[0] {
		case 10:
			b = b[1:]
			x, n := proto.DecodeVarint(b)
			if n == 0 {
				return proto.ErrInternalBadWireType
			}
			b = b[n:]
			if x > uint64(len(b)) {
				return proto.ErrInternalBadWireType
			}
			p := b[:x]
			b = b[x:]
			for len(p) > 0 {
				if len(p) < 4 {
					return proto.ErrInternalBadWireType
				}
				v := math.Float32frombits(uint32(p[0]) | uint32(p[1])<<8 | uint32(p[2])<<16 | uint32(p[3])<<24)
				m.F1 = append(m.F1, v)
				p = p[4:]
			}
			continue loop
		case 13:
			b = b[1:]
			if len(b) < 4 {
				return proto.ErrInternalBadWireType
			}
			v := math.Float32frombits(uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24)
			b = b[4:]
			m.F1 = append(m.F1, v)
			continue loop
		case 16:
			b = b[1:]
			x, n := proto.DecodeVarint(b)
			if n == 0 {
				return proto.ErrInternalBadWireType
			}
			b = b[n:]
			v := int64(x>>1) ^ int64(x)<<63>>63
			m.F2 = v
			continue loop
		case 26:
			b = b[1:]
			x, n := proto.DecodeVarint(b)
			if n == 0 {
				return proto.ErrInternalBadWireType
			}
			b = b[n:]
			if uint64(len(b)) < x {
				return proto.ErrInternalBadWireType
			}
			v := new(B3)
			if err := v.MergeFullCustom(b[:x]); err != nil {
				if r, ok := err.(*proto.RequiredNotSetError); ok {
					r.AddParent("f3")
					rnse = r
				} else {
					return err
				}
			}
			b = b[x:]
			m.F3 = append(m.F3, v)
			continue loop
		}
		b = proto.SkipUnrecognized2(b, nil)
	}
	if rnse != nil {
		return rnse
	}
	return nil
}
func (m *B2) MergeReflectTable(b []byte) error {
	return proto.UnmarshalReflect(m, b, &xxx_unmarshalInfoPtr_B2)
}

var xxx_unmarshalInfoPtr_B2 *proto.UnmarshalInfo

type B3 struct {
	F1 []string `protobuf:"bytes,1,rep,name=f1" json:"f1,omitempty"`
	F2 string   `protobuf:"bytes,2,opt,name=f2" json:"f2,omitempty"`
}

func (m *B3) Reset()                    { *m = B3{} }
func (m *B3) String() string            { return proto.CompactTextString(m) }
func (*B3) ProtoMessage()               {}
func (*B3) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *B3) MergeFullCustom(b []byte) error {
loop:
	for {
		if len(b) == 0 {
			break
		}
		switch b[0] {
		case 10:
			b = b[1:]
			x, n := proto.DecodeVarint(b)
			if n == 0 {
				return proto.ErrInternalBadWireType
			}
			b = b[n:]
			if uint64(len(b)) < x {
				return proto.ErrInternalBadWireType
			}
			v := string(b[:x])
			b = b[x:]
			m.F1 = append(m.F1, v)
			continue loop
		case 18:
			b = b[1:]
			x, n := proto.DecodeVarint(b)
			if n == 0 {
				return proto.ErrInternalBadWireType
			}
			b = b[n:]
			if uint64(len(b)) < x {
				return proto.ErrInternalBadWireType
			}
			v := string(b[:x])
			b = b[x:]
			m.F2 = v
			continue loop
		}
		b = proto.SkipUnrecognized2(b, nil)
	}
	return nil
}
func (m *B3) MergeReflectTable(b []byte) error {
	return proto.UnmarshalReflect(m, b, &xxx_unmarshalInfoPtr_B3)
}

var xxx_unmarshalInfoPtr_B3 *proto.UnmarshalInfo

func init() {
	proto.RegisterType((*A)(nil), "protobench.A")
	proto.RegisterType((*B)(nil), "protobench.B")
	proto.RegisterType((*B2)(nil), "protobench.B2")
	proto.RegisterType((*B3)(nil), "protobench.B3")
}

func init() { proto.RegisterFile("msg.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 223 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0xd0, 0xcf, 0x4a, 0xc4, 0x30,
	0x10, 0x06, 0x70, 0x92, 0xb8, 0xdd, 0xcd, 0x08, 0x8b, 0xe6, 0x34, 0xa7, 0x45, 0x82, 0x07, 0x4f,
	0xc5, 0x4d, 0x76, 0xfb, 0xe7, 0x68, 0xf1, 0x09, 0xfa, 0x08, 0x2d, 0x56, 0x2f, 0x5a, 0x51, 0x5f,
	0xc9, 0xf7, 0xf4, 0xcb, 0x50, 0x6a, 0x29, 0x82, 0xa7, 0xce, 0xaf, 0xa5, 0x5f, 0xbe, 0x09, 0xd9,
	0xd7, 0xcf, 0xe7, 0xfc, 0xfd, 0x63, 0xfc, 0x1a, 0x1d, 0xc9, 0xa3, 0x7b, 0x7a, 0xeb, 0x5f, 0xfc,
	0xb7, 0x22, 0xf5, 0xe0, 0xf6, 0xa4, 0x87, 0x23, 0xab, 0x1b, 0x75, 0x67, 0x5a, 0x4c, 0xe2, 0xc0,
	0x7a, 0x72, 0x10, 0x47, 0x36, 0xf0, 0x06, 0x8e, 0xe2, 0x13, 0x5f, 0xc0, 0x3b, 0xf8, 0x24, 0x3e,
	0xf3, 0x06, 0xd6, 0xf0, 0x59, 0x5c, 0x70, 0x06, 0x2b, 0xb8, 0x10, 0x97, 0xbc, 0x85, 0x33, 0xb8,
	0x14, 0x57, 0xbc, 0x83, 0xb7, 0x70, 0x25, 0xae, 0xd9, 0xc2, 0xd7, 0x70, 0xed, 0xae, 0xc8, 0x0c,
	0xc7, 0x7b, 0x26, 0xbc, 0x70, 0x6d, 0x1a, 0x7d, 0x4f, 0xaa, 0x99, 0x6b, 0x9a, 0xa9, 0xe6, 0x61,
	0xae, 0x79, 0x19, 0xf6, 0xf9, 0xef, 0x56, 0x79, 0x13, 0xa4, 0xf6, 0x61, 0xaa, 0x6d, 0xfe, 0xfc,
	0xbe, 0x5c, 0xc3, 0xa6, 0x35, 0xfc, 0x23, 0xe9, 0x26, 0x2c, 0x4e, 0xd1, 0xab, 0xcb, 0x70, 0xff,
	0xa4, 0xc6, 0x94, 0xea, 0x6f, 0x91, 0x12, 0x17, 0x29, 0x76, 0x95, 0x92, 0x1c, 0xba, 0x4c, 0x7e,
	0x8c, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x31, 0xa5, 0x48, 0x76, 0x98, 0x01, 0x00, 0x00,
}
